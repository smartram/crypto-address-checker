use wasm_bindgen::prelude::*;
use serde::{Deserialize, Serialize};
use regex::Regex;
use base58::FromBase58;
use sha2::{Sha256, Digest};

#[derive(Serialize, Deserialize)]
pub struct AddressInfo {
    pub address: String,
    pub network: String,
    pub valid: bool,
    pub address_type: String,
}

#[wasm_bindgen]
pub fn identify_crypto_address(address: &str) -> JsValue {
    let result = check_address(address);
    serde_wasm_bindgen::to_value(&result).unwrap()
}

fn check_address(address: &str) -> AddressInfo {
    let address = address.trim();
    
    // Debug: log the address being checked
    web_sys::console::log_1(&format!("Checking address: {}", address).into());
    
    // Bitcoin addresses
    if is_bitcoin_address(address) {
        web_sys::console::log_1(&"Identified as Bitcoin".into());
        return AddressInfo {
            address: address.to_string(),
            network: "Bitcoin".to_string(),
            valid: true,
            address_type: get_bitcoin_address_type(address),
        };
    }
    
    // Ethereum addresses
    if is_ethereum_address(address) {
        web_sys::console::log_1(&"Identified as Ethereum".into());
        return AddressInfo {
            address: address.to_string(),
            network: "Ethereum".to_string(),
            valid: true,
            address_type: "Standard".to_string(),
        };
    }

    if is_polkadot_address(address) {
	web_sys::console::log_1(&"Identfied as Polkadot or parachain".into());
	return AddressInfo {
	    address: address.to_string(),
	    network: "Polkadot".to_string(),
	    valid: true,
            address_type: "Polkadot".to_string(),
	};
     }
    
    // Litecoin addresses
    if is_litecoin_address(address) {
        web_sys::console::log_1(&"Identified as Litecoin".into());
        return AddressInfo {
            address: address.to_string(),
            network: "Litecoin".to_string(),
            valid: true,
            address_type: get_litecoin_address_type(address),
        };
    }
    
    // Dogecoin addresses
    if is_dogecoin_address(address) {
        web_sys::console::log_1(&"Identified as Dogecoin".into());
        return AddressInfo {
            address: address.to_string(),
            network: "Dogecoin".to_string(),
            valid: true,
            address_type: "Standard".to_string(),
        };
    }
    
    // Solana addresses
    if is_solana_address(address) {
        web_sys::console::log_1(&"Identified as Solana".into());
        return AddressInfo {
            address: address.to_string(),
            network: "Solana".to_string(),
            valid: true,
            address_type: "Standard".to_string(),
        };
    }
    
    // Cardano addresses
    if is_cardano_address(address) {
        web_sys::console::log_1(&"Identified as Cardano".into());
        return AddressInfo {
            address: address.to_string(),
            network: "Cardano".to_string(),
            valid: true,
            address_type: "Bech32".to_string(),
        };
    }
    
    // Invalid or unknown address
    web_sys::console::log_1(&"Address not recognized".into());
    AddressInfo {
        address: address.to_string(),
        network: "Unknown".to_string(),
        valid: false,
        address_type: "Unknown".to_string(),
    }
}

fn is_bitcoin_address(address: &str) -> bool {
    // Legacy addresses (1...)
    if address.starts_with('1') && address.len() >= 26 && address.len() <= 35 {
        return validate_base58_checksum(address);
    }
    
    // Script addresses (3...)
    if address.starts_with('3') && address.len() >= 26 && address.len() <= 35 {
        return validate_base58_checksum(address);
    }
    
    // Bech32 addresses (bc1...)
    if address.starts_with("bc1") && address.len() >= 42 && address.len() <= 62 {
        return validate_bech32(address);
    }
    
    false
}

fn get_bitcoin_address_type(address: &str) -> String {
    if address.starts_with('1') {
        "Legacy (P2PKH)".to_string()
    } else if address.starts_with('3') {
        "Script (P2SH)".to_string()
    } else if address.starts_with("bc1") {
        "Bech32 (P2WPKH/P2WSH)".to_string()
    } else {
        "Unknown".to_string()
    }
}

fn is_ethereum_address(address: &str) -> bool {
    // Check if it starts with 0x and has exactly 40 hex characters after
    web_sys::console::log_1(&format!("ETH check - address: {}, len: {}", address, address.len()).into());
    
    if !address.starts_with("0x") || address.len() != 42 {
        web_sys::console::log_1(&format!("ETH check failed - starts_with: {}, len: {}", address.starts_with("0x"), address.len()).into());
        return false;
    }
    
    // Check if all characters after 0x are valid hex
    let hex_part = &address[2..];
    let is_valid_hex = hex_part.chars().all(|c| c.is_ascii_hexdigit());
    web_sys::console::log_1(&format!("ETH check - hex_part: {}, is_valid_hex: {}", hex_part, is_valid_hex).into());
    
    is_valid_hex
}

fn is_litecoin_address(address: &str) -> bool {
    // Legacy addresses (L... or M...)
    if (address.starts_with('L') || address.starts_with('M')) && address.len() >= 26 && address.len() <= 35 {
        return validate_base58_checksum(address);
    }
    
    // Bech32 addresses (ltc1...)
    if address.starts_with("ltc1") && address.len() >= 43 && address.len() <= 63 {
        return validate_bech32(address);
    }
    
    false
}

fn get_litecoin_address_type(address: &str) -> String {
    if address.starts_with('L') {
        "Legacy (P2PKH)".to_string()
    } else if address.starts_with('M') {
        "Script (P2SH)".to_string()
    } else if address.starts_with("ltc1") {
        "Bech32".to_string()
    } else {
        "Unknown".to_string()
    }
}

fn is_dogecoin_address(address: &str) -> bool {
    (address.starts_with('D') || address.starts_with('A')) && 
    address.len() >= 26 && address.len() <= 35 && 
    validate_base58_checksum(address)
}

fn is_solana_address(address: &str) -> bool {
    address.len() >= 32 && address.len() <= 44 && 
    address.chars().all(|c| c.is_ascii_alphanumeric()) &&
    !address.starts_with('0') && !address.starts_with('O') &&
    !address.starts_with('I') && !address.starts_with('l')
}

fn is_cardano_address(address: &str) -> bool {
    address.starts_with("addr1") && address.len() >= 100 && address.len() <= 110
}

fn is_polkadot_address(address: &str) -> bool {
   let polkadot_regex = Regex::new(r"^[1-9A-HJ-NP-Za-km-z]{47,48}$").unwrap();
   return polkadot_regex.is_match(address);
}

fn validate_base58_checksum(address: &str) -> bool {
    match address.from_base58() {
        Ok(decoded) => {
            if decoded.len() < 4 {
                return false;
            }
            
            let (payload, checksum) = decoded.split_at(decoded.len() - 4);
            let hash = Sha256::digest(&Sha256::digest(payload));
            &hash[..4] == checksum
        }
        Err(_) => false,
    }
}

fn validate_bech32(address: &str) -> bool {
    // Simplified bech32 validation
    // In a real implementation, you'd use a proper bech32 library
    let re = Regex::new(r"^[a-z0-9]{1,83}$").unwrap();
    let parts: Vec<&str> = address.split('1').collect();
    
    if parts.len() != 2 {
        return false;
    }
    
    let (hrp, data) = (parts[0], parts[1]);
    
    // Check human readable part
    if hrp.is_empty() || hrp.len() > 83 {
        return false;
    }
    
    // Check data part
    if data.len() < 6 || !re.is_match(data) {
        return false;
    }
    
    true
}

#[wasm_bindgen(start)]
pub fn main() {
    console_error_panic_hook::set_once();
}
